# aws cloudformation delete-stack --stack-name iris-model-pipeline
# aws cloudformation create-stack --stack-name iris-model-pipeline --template-body file://build-model-pipeline.yml

Description: Create a CodePipeline for a Machine Learning Model
Parameters:
  GitHubToken:
    NoEcho: true
    Description: Secret. It might look something like 9b189a1654643522561f7b3ebd44a1531a4287af OAuthToken with access to Repo. Go to https://github.com/settings/tokens
    Type: String
  GitHubUser:
    Default: brightsparc
    Description: GitHub UserName
    Type: String
  CodeRepoName:
    Type: String
    Description: Name of the CodeCommit repo
  CodeBranchName:
    Type: String
    Description: Name of the branch the code is located
  ImageRepoName:
    Type: String
    Description: Name of the ECR repo without the image name
  ImageTagName:
    Type: String
    Description: Name of the ECR image tag
    Default: latest
  ModelName:
    Type: String
    Description: Name of the model
  ArtifactBucket:
    Type: String
    Description: The bucket for pipeline artifacts
    Default: latest
  MLOpsRoleArn:
    Type: String
    Description: Role for Lambda, CodePipeline and Cloudformation
    Default: latest

Resources:

  BuildProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub ${AWS::StackName}-mlops-build
      Description: Builds the assets required for executing the rest of pipeline
      ServiceRole: !Ref MLOpsRoleArn
      Artifacts:
        Type: CODEPIPELINE
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/amazonlinux2-x86_64-standard:1.0
      Source:
        Type: CODEPIPELINE
        BuildSpec: workflow/buildspec.yml
      TimeoutInMinutes: 30
    
  MLOpsLaunchJob:
    Type: "AWS::Lambda::Function"
    Properties: 
      FunctionName: !Sub ${AWS::StackName}-job-launcher
      Handler: index.lambda_handler
      MemorySize: 512
      Role: !Ref MLOpsRoleArn 
      Runtime: python3.6
      Timeout: 60
      Code: 
        ZipFile: !Sub |
          import boto3
          import io
          import zipfile
          import json

          s3 = boto3.client('s3')
          sm = boto3.client('sagemaker')
          codepipeline = boto3.client('codepipeline')

          def lambda_handler(event, context):
              print('event', json.dumps(event))
              jobId = event["CodePipeline.job"]["id"]
              trainingJob = None

              try:
                  for inputArtifacts in event["CodePipeline.job"]["data"]["inputArtifacts"]:
                      if inputArtifacts['name'] == 'BuildOutput':
                          s3Location = inputArtifacts['location']['s3Location']
                          zip_bytes = s3.get_object(Bucket=s3Location['bucketName'], Key=s3Location['objectKey'])['Body'].read()
                          with zipfile.ZipFile(io.BytesIO(zip_bytes), "r") as z:
                            trainingJob = json.loads(z.read('trainingjob.json').decode('utf-8'))
                            experiment = json.loads(z.read('experiment.json').decode('utf-8'))
                            trial = json.loads(z.read('trial.json').decode('utf-8'))

                  if trainingJob is None:
                    raise(Exception("training.json wasn't found"))

                  try:
                      response = sm.create_experiment(**experiment)
                      print('created exp', response)
                  except Exception as e:
                      pass
                  try:
                      response = sm.create_trial(**trial)
                      print('created trial', response)
                  except Exception as e:
                      pass

                  print('Start training job %s' % (trainingJob['TrainingJobName']))      
                  sm.create_training_job(**trainingJob)
 
                  # and update codepipeline
                  codepipeline.put_job_success_result(jobId=jobId)
              except Exception as e:
                  print(e)
                  resp = codepipeline.put_job_failure_result(
                      jobId=jobId,
                      failureDetails={
                          'type': 'ConfigurationError',
                          'message': str(e),
                          'externalExecutionId': context.aws_request_id
                      }
                  )
              return 'Done'

      Description: "Function that will start a new Sagemaker Training Job"
      Tags:
        - Key: Name
          Value: !Sub mlops-launch-job-${ModelName}

  DeployPipeline:
    Type: "AWS::CodePipeline::Pipeline"
    Properties:
      Name: !Sub ${AWS::StackName}
      RoleArn: !Ref MLOpsRoleArn
      ArtifactStore:
          Type: S3
          Location:
            Ref: ArtifactBucket
      Stages:
        -
          Name: Source
          Actions: 
            - 
              Name: GitSource
              ActionTypeId: 
                Category: Source
                Owner: ThirdParty
                Version: 1
                Provider: GitHub
              OutputArtifacts: 
                - Name: ModelSourceOutput
              Configuration: 
                Owner: !Ref GitHubUser
                Repo: !Ref CodeRepoName
                Branch: !Ref CodeBranchName
                OAuthToken: !Ref GitHubToken
            -
              Name: EcrSource
              ActionTypeId:
                Category: Source
                Owner: AWS
                Version: 1
                Provider: ECR
              OutputArtifacts:
                - Name: EcrSourceOutput
              Configuration:
                ImageTag: !Ref ImageTagName
                RepositoryName: !Ref ImageRepoName
              RunOrder: 1
            -
              Name: DataSource
              ActionTypeId:
                Category: Source
                Owner: AWS
                Version: 1
                Provider: S3
              OutputArtifacts:
                - Name: DataSourceOutput
              Configuration:
                S3Bucket: !Ref ArtifactBucket
                S3ObjectKey: data-source.zip
              RunOrder: 1
        -
          Name: Build
          Actions:
            -
              Name: BuildTemplates
              InputArtifacts:
                - Name: ModelSourceOutput
                - Name: EcrSourceOutput
                - Name: DataSourceOutput
              OutputArtifacts:
                - Name: BuildOutput
              ActionTypeId:
                Category: Build
                Owner: AWS
                Version: 1
                Provider: CodeBuild
              Configuration:
                ProjectName: !Ref BuildProject
                PrimarySource: ModelSourceOutput
                EnvironmentVariables: !Sub '[{"name":"DATA_BUCKET","value":"sagemaker-${AWS::Region}-${AWS::AccountId}","type":"PLAINTEXT"},{"name":"MODEL_NAME","value":"${ModelName}","type":"PLAINTEXT"},{"name":"ROLE_ARN","value":"${MLOpsRoleArn}","type":"PLAINTEXT"},{"name":"ARTIFACT_BUCKET","value":"${ArtifactBucket}","type":"PLAINTEXT"}]'
              RunOrder: 1
            -
              Name: CustomResource
              InputArtifacts:
                - Name: BuildOutput
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CloudFormation
              Configuration:
                ActionMode: REPLACE_ON_FAILURE
                RoleArn: !Ref MLOpsRoleArn
                Capabilities: CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND
                StackName: !Sub ${AWS::StackName}-custom-resource
                TemplatePath: BuildOutput::template-custom-resource.yml
              RunOrder: 2
        -
          Name: Baseline
          Actions:
            -
              Name: SuggestBaseline
              InputArtifacts:
                - Name: BuildOutput
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CloudFormation
              Configuration:
                ActionMode: REPLACE_ON_FAILURE
                RoleArn: !Ref MLOpsRoleArn
                StackName: !Sub ${AWS::StackName}-suggest-baseline
                TemplateConfiguration: BuildOutput::suggest-baseline.json
                TemplatePath: BuildOutput::suggest-baseline.yml
              RunOrder: 1
            -
              Name: ApproveBaseline
              ActionTypeId:
                Category: Approval
                Owner: AWS
                Version: 1
                Provider: Manual
              Configuration:
                CustomData: 'Are you happy to proceed with training?'
              RunOrder: 2
        -
          Name: Train
          Actions:
            -
              Name: TrainModel
              InputArtifacts:
                - Name: BuildOutput
              ActionTypeId:
                Category: Invoke
                Owner: AWS
                Version: 1
                Provider: Lambda
              Configuration:
                  FunctionName: !Ref MLOpsLaunchJob
                  UserParameters: !Sub mlops-pipeline-${ModelName}
              RunOrder: 1
            - 
              Name: WaitForTraining
              InputArtifacts:
                - Name: BuildOutput
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CloudFormation
              Configuration:
                ActionMode: REPLACE_ON_FAILURE
                RoleArn: !Ref MLOpsRoleArn
                StackName: !Sub ${AWS::StackName}-wait-training-job
                TemplateConfiguration: BuildOutput::training-job.json
                TemplatePath: BuildOutput::wait-training-job.yml
              RunOrder: 2
            -
              Name: ApproveTrain
              ActionTypeId:
                Category: Approval
                Owner: AWS
                Version: 1
                Provider: Manual
              Configuration:
                CustomData: 'Does this training job look good'
              RunOrder: 3
        -
          Name: DeployDev
          Actions:
            - 
              Name: DeployModelDev
              InputArtifacts:
                - Name: BuildOutput
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CloudFormation
              Configuration:
                ActionMode: REPLACE_ON_FAILURE
                RoleArn: !Ref MLOpsRoleArn
                Capabilities: CAPABILITY_NAMED_IAM
                StackName: !Sub ${AWS::StackName}-deploy-dev
                TemplateConfiguration: BuildOutput::deploy-model-dev.json
                TemplatePath: BuildOutput::deploy-model-dev.yml
              RunOrder: 1
            -
              Name: ApproveDeploy
              ActionTypeId:
                Category: Approval
                Owner: AWS
                Version: 1
                Provider: Manual
              Configuration:
                CustomData: 'Shall this model be put into production?'
              RunOrder: 2
        -
          Name: DeployPrd
          Actions:
            - 
              Name: DeployModelPrd
              InputArtifacts:
                - Name: BuildOutput
              OutputArtifacts:
                - Name: ModelDeployPrdOutput
              ActionTypeId:
                Category: Deploy
                Owner: AWS
                Version: 1
                Provider: CloudFormation                
              Configuration:
                ActionMode: CREATE_UPDATE
                RoleArn: !Ref MLOpsRoleArn
                Capabilities: CAPABILITY_NAMED_IAM,CAPABILITY_AUTO_EXPAND
                StackName: !Sub ${AWS::StackName}-deploy-prd
                TemplateConfiguration: BuildOutput::template-model-prd.json
                TemplatePath: BuildOutput::template-model-prd.yml
              RunOrder: 1

  MLOpsJobMonitor:
    Type: "AWS::Lambda::Function"
    Properties: 
      FunctionName: !Sub ${AWS::StackName}-mlops-monitor
      Handler: index.lambda_handler
      Runtime: python3.7
      MemorySize: 512
      Role: !Ref MLOpsRoleArn
      Runtime: python3.6
      Timeout: 60
      Code: 
        ZipFile: !Sub |
          import boto3
          import json
          codepipeline = boto3.client('codepipeline')
          def lambda_handler(event, context):
            print('event', json.dumps(event))
            # Define stage and action name
            stage_name = event['detail']['stage']
            action_name = event['detail']['action']
            status = event['detail']['state']
            print('stage: {}/{} status: {}', stage_name, action_name, status)
            # The pipeline will be the same name step function workflow
            pipeline_name = '${AWS::StackName}'
            response = codepipeline.get_pipeline_state( name=pipeline_name )
            print('get_pipeline_state', response)
            token = None
            for stageState in response['stageStates']:
              if stageState['stageName'] == stage_name:
                for actionState in stageState['actionStates']:
                  if actionState['actionName'] == action_name:
                    if not 'latestExecution' in actionState:
                      raise(Exception("Approval not available"))
                    else:
                      latestExecution = actionState['latestExecution']
                      if latestExecution['status'] != 'InProgress':
                        raise(Exception("Approval is not awaiting for approval: %s" % latestExecution['status']))
                      token = latestExecution['token']
            if token is None:
              return "No token found"
            # TODO: If Baseline, automatically approve when Complete without viloations
            # TODO: If Training, automatically approve when no rule violoations
            # Check status
            if status == 'SUCCEEDED':
              result={
                  'summary': 'Model trained successfully',
                  'status': 'Approved'
                }
            else:
              result={
                'summary': 'Workflow unsuccesful with status: {}'.format(status),
                'status': 'Rejected'
              }
            # Update approval
            response = codepipeline.put_approval_result(
              pipelineName=pipeline_name,
              stageName=stage_name,
              actionName=action_name,
              result=result,
              token=token
            )
            print('put_approval_result', response)
            return "Done"
      Description: "Function called when a step function workflow is complete"
      
  MLOpsJobMonitorPermissions:
    Type: "AWS::Lambda::Permission"
    Properties: 
      Action: lambda:InvokeFunction
      FunctionName: !Ref MLOpsJobMonitor
      Principal: events.amazonaws.com
      SourceArn: !GetAtt JobMonitoringEvent.Arn

  JobMonitoringEvent:
    Type: "AWS::Events::Rule"
    Properties: 
      Description: "Event that will be called when pipeline actions "
      Name: !Sub ${AWS::StackName}-mlops-monitor
      EventPattern: 
        source: 
          - "aws.codepipeline"
        detail-type: 
          - "CodePipeline Action Execution State Change"
        detail: 
          pipeline:
            - !Ref DeployPipeline
          state:
            - "SUCCEEDED"
            - "FAILED"
      Targets:
        - Arn: !GetAtt MLOpsJobMonitor.Arn
          Id: !Sub ${AWS::StackName}-mlops-event
    DependsOn: MLOpsJobMonitor